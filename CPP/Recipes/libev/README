libev 利用Reactor实现高性能的事件循环库:
    分离事件处理和业务逻辑
    抽象一套通用的多路复用接口
    抽象io/timer/signal
EV_WATCHER:
    int active; // watcher 是否活跃，1 alive
    int pending; // 存储watcher在pendings的索引 >0 表示未被处理
    int proority; // 优先级
    void *data; // 回调函数需要的数据
    void (*cb) (EV_P_ struct type *w, int revents);
EV_WATCHER_LIST:
    struct ev_watcher_list *next;
ev_io:
    ev_io {
        struct ev_watcher_list *next;
        int fd;
        int event;
        };
===============================================================
EV_P_ 函数声明的形参
EV_A_ 函数调用的实参
Watcher 一个或多个事件的监听器

使用流程:
    初始化框架:
        struct ev_loop *loop = EV_DEFAULT;
        struct ev_loop *loop = ev_default_loop(0);
        struct ev_loop *loop = ev_loop_new(EVBACKEND_EPOLL);
        //ev_loop_destroy(loop);
    初始化监听器:
        ev_TYPE w;
        ev_TYPE_init (w, cb, ...);
    加入到loop的监控器列表:
        ev_TYPE_start(loop, w);
    loop 开始处理事件:
        ev_run(loop, 0);
===============================================================
libev default config:
===============================================================
libev error handling:os error,usage error,internal error
os error -> ev_set_syserr_cb -> abort()
usage error -> assert...
internal error -> ...
===============================================================
libev global function:
typedef double ev_tstamp;
ev_tstamp ev_time() -> current time
ev_sleep(ev_tstamp internal)
